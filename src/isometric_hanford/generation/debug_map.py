"""
Debug Map - Visualize generated quadrants on a real map of NYC.

This script creates an interactive web visualization showing which quadrants
have been generated by overlaying polygons on a real map using Leaflet.js.
Hovering over quadrants shows their x,y coordinates.

Usage:
  uv run python src/isometric_hanford/generation/debug_map.py [generation_dir]
  uv run python src/isometric_hanford/generation/debug_map.py [generation_dir] --bounds path/to/bounds.json

Arguments:
  generation_dir: Path to the generation directory (default: generations/nyc)
  --bounds: Path to a custom bounds GeoJSON file (default: NYC boundary)

Output:
  Creates debug_map.html in the generation directory
"""

import argparse
import json
import sqlite3
from pathlib import Path

from isometric_hanford.generation.bounds import load_bounds
from isometric_hanford.generation.shared import calculate_offset

# fmt: on


def get_generation_config(conn: sqlite3.Connection) -> dict:
  """Get the generation config from the metadata table."""
  cursor = conn.cursor()
  cursor.execute("SELECT value FROM metadata WHERE key = 'generation_config'")
  row = cursor.fetchone()
  if not row:
    raise ValueError("generation_config not found in metadata")
  return json.loads(row[0])


def get_generated_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int, int]]:
  """
  Get all quadrants that have been generated (have generation data).

  Returns list of (quadrant_x, quadrant_y, water_status) tuples.
  water_status: -1 = explicit not water, 0 = unset, 1 = water
  """
  cursor = conn.cursor()

  # Check if is_water column exists
  cursor.execute("PRAGMA table_info(quadrants)")
  columns = [row[1] for row in cursor.fetchall()]
  has_water_column = "is_water" in columns

  if has_water_column:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y, COALESCE(is_water, 0)
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], row[2]) for row in cursor.fetchall()]
  else:
    cursor.execute("""
      SELECT quadrant_x, quadrant_y
      FROM quadrants
      WHERE generation IS NOT NULL
      ORDER BY quadrant_x, quadrant_y
    """)
    return [(row[0], row[1], 0) for row in cursor.fetchall()]


def get_pending_quadrants(
  conn: sqlite3.Connection,
) -> list[tuple[int, int]]:
  """
  Get all unique quadrants from pending queue items.

  Returns list of (quadrant_x, quadrant_y) tuples.
  """
  cursor = conn.cursor()

  # Check if generation_queue table exists
  cursor.execute("""
    SELECT name FROM sqlite_master
    WHERE type='table' AND name='generation_queue'
  """)
  if not cursor.fetchone():
    return []

  # Get all pending queue items and extract their quadrants
  cursor.execute("""
    SELECT quadrants FROM generation_queue
    WHERE status = 'pending'
  """)

  pending_set: set[tuple[int, int]] = set()
  for (quadrants_json,) in cursor.fetchall():
    quadrants = json.loads(quadrants_json)
    for qx, qy in quadrants:
      pending_set.add((qx, qy))

  return sorted(pending_set)


def calculate_quadrant_corners(
  config: dict, quadrant_x: int, quadrant_y: int
) -> list[tuple[float, float]]:
  """
  Calculate the 4 geographic corners of a quadrant.

  The isometric projection means the quadrant appears as a parallelogram
  in geographic space. Returns corners in order: TL, TR, BR, BL.

  Args:
    config: Generation config dictionary
    quadrant_x: X coordinate of the quadrant
    quadrant_y: Y coordinate of the quadrant

  Returns:
    List of 4 (lat, lng) tuples representing the corners
  """
  seed_lat = config["seed"]["lat"]
  seed_lng = config["seed"]["lng"]
  width_px = config["width_px"]
  height_px = config["height_px"]
  view_height_meters = config["view_height_meters"]
  azimuth = config["camera_azimuth_degrees"]
  elevation = config["camera_elevation_degrees"]
  tile_step = config.get("tile_step", 0.5)

  # Each quadrant is half a tile in size
  quadrant_width_px = width_px * tile_step
  quadrant_height_px = height_px * tile_step

  # Calculate the pixel offsets for the 4 corners of this quadrant
  # Quadrant (0,0) has its bottom-right corner at the seed position
  # So we need to calculate corners relative to the seed
  base_x_px = quadrant_x * quadrant_width_px
  base_y_px = -quadrant_y * quadrant_height_px  # Negative because y increases down

  # Corner offsets in pixels (relative to the quadrant's anchor)
  # TL, TR, BR, BL - going clockwise
  corner_offsets = [
    (-quadrant_width_px, quadrant_height_px),  # TL: left and up from anchor
    (0, quadrant_height_px),  # TR: up from anchor
    (0, 0),  # BR: at anchor
    (-quadrant_width_px, 0),  # BL: left from anchor
  ]

  corners = []
  for dx, dy in corner_offsets:
    shift_x_px = base_x_px + dx
    shift_y_px = base_y_px + dy

    lat, lng = calculate_offset(
      seed_lat,
      seed_lng,
      shift_x_px,
      shift_y_px,
      view_height_meters,
      height_px,
      azimuth,
      elevation,
    )
    corners.append((lat, lng))

  return corners


def generate_html(
  config: dict,
  quadrant_polygons: list[tuple[int, int, list[tuple[float, float]], int]],
  pending_polygons: list[tuple[int, int, list[tuple[float, float]]]],
  seed_lat: float,
  seed_lng: float,
  center_lat: float,
  center_lng: float,
  boundary_geojson: dict | None = None,
) -> str:
  """Generate the HTML content for the debug map."""

  # Convert quadrant data to JSON for JavaScript
  # water_status: -1 = explicit not water, 0 = unset, 1 = water
  quadrants_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
        "water_status": water_status,
      }
      for qx, qy, corners, water_status in quadrant_polygons
    ]
  )

  # Convert pending quadrant data to JSON for JavaScript
  pending_json = json.dumps(
    [
      {
        "x": qx,
        "y": qy,
        "corners": [[lat, lng] for lat, lng in corners],
      }
      for qx, qy, corners in pending_polygons
    ]
  )

  # Boundary GeoJSON for the map (default to NYC if not provided)
  if boundary_geojson is None:
    boundary_geojson = load_bounds()
  nyc_boundary_json = json.dumps(boundary_geojson)

  html = f"""<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Map - {config.get("name", "Generation")}</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap');

    * {{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }}

    body {{
      font-family: 'Space Grotesk', sans-serif;
      background: #0a0a0f;
    }}

    #map {{
      width: 100vw;
      height: 100vh;
    }}

    .info-panel {{
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px 20px;
      color: #fff;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .info-panel h3 {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 8px;
    }}

    .coords {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 28px;
      font-weight: 600;
      color: #fff;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }}

    .coords .label {{
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
    }}

    .coords .x {{
      color: #ff6b6b;
    }}

    .coords .y {{
      color: #4ecdc4;
    }}

    .coords .separator {{
      color: rgba(255, 255, 255, 0.3);
      font-size: 20px;
    }}

    .no-hover {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.3);
      font-style: italic;
    }}

    .stats-panel {{
      position: fixed;
      bottom: 16px;
      left: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }}

    .stats-panel .title {{
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 4px;
    }}

    .stats-panel .count {{
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }}

    .legend {{
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(10, 10, 15, 0.92);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 14px 18px;
      color: #fff;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }}

    .legend-item {{
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
    }}

    .legend-swatch {{
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }}

    .legend-swatch.quadrant {{
      background: rgba(255, 107, 107, 0.35);
      border: 2px solid rgba(255, 107, 107, 0.7);
    }}

    .legend-swatch.water {{
      background: rgba(59, 130, 246, 0.35);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.protected {{
      background: rgba(220, 38, 38, 0.25);
      border: 2px dashed rgba(220, 38, 38, 0.7);
    }}

    .legend-swatch.seed {{
      background: #10b981;
      border: 2px solid #fff;
      border-radius: 50%;
    }}

    .legend-swatch.nyc-boundary {{
      background: rgba(59, 130, 246, 0.15);
      border: 2px solid rgba(59, 130, 246, 0.7);
    }}

    .legend-swatch.pending {{
      background: rgba(168, 85, 247, 0.35);
      border: 2px solid rgba(168, 85, 247, 0.7);
    }}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info-panel">
    <h3>Quadrant</h3>
    <div id="coords-display" class="no-hover">Hover over a tile</div>
  </div>

  <div class="stats-panel">
    <div class="title">{config.get("name", "Debug Map")}</div>
    <div class="count">{len(quadrant_polygons)} quadrants generated</div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch nyc-boundary"></div>
      <span>NYC Boundary</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch quadrant"></div>
      <span>Generated Quadrant</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch water"></div>
      <span>Water Tile</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch protected"></div>
      <span>Protected (Not Water)</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch pending"></div>
      <span>Pending Generation</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch seed"></div>
      <span>Seed Point</span>
    </div>
  </div>

  <script>
    const quadrants = {quadrants_json};
    const pendingQuadrants = {pending_json};
    const nycBoundary = {nyc_boundary_json};
    const seedLat = {seed_lat};
    const seedLng = {seed_lng};
    const centerLat = {center_lat};
    const centerLng = {center_lng};

    // Initialize map
    const map = L.map('map', {{
      zoomControl: true,
      attributionControl: true
    }}).setView([centerLat, centerLng], 15);

    // Add dark tile layer
    L.tileLayer('https://{{s}}.basemaps.cartocdn.com/dark_all/{{z}}/{{x}}/{{y}}{{r}}.png', {{
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }}).addTo(map);

    // Add NYC boundary layer (underneath quadrants)
    const nycBoundaryStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.1,
      color: '#3b82f6',
      weight: 2,
      opacity: 0.6
    }};

    L.geoJSON(nycBoundary, {{
      style: nycBoundaryStyle
    }}).addTo(map);

    const coordsDisplay = document.getElementById('coords-display');

    // Style for normal state (red for land)
    const normalStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.25,
      color: '#ff6b6b',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for hover state (land)
    const hoverStyle = {{
      fillColor: '#ff6b6b',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for water tiles (blue)
    const waterStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.35,
      color: '#3b82f6',
      weight: 1.5,
      opacity: 0.7
    }};

    // Style for water hover state
    const waterHoverStyle = {{
      fillColor: '#3b82f6',
      fillOpacity: 0.6,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Style for protected (explicit not water) tiles
    const protectedStyle = {{
      fillColor: '#dc2626',
      fillOpacity: 0.2,
      color: '#dc2626',
      weight: 1.5,
      opacity: 0.6,
      dashArray: '5, 5'
    }};

    // Style for protected hover state
    const protectedHoverStyle = {{
      fillColor: '#dc2626',
      fillOpacity: 0.4,
      color: '#fff',
      weight: 2,
      opacity: 1,
      dashArray: '5, 5'
    }};

    // Style for pending quadrants (purple)
    const pendingStyle = {{
      fillColor: '#a855f7',
      fillOpacity: 0.25,
      color: '#a855f7',
      weight: 1.5,
      opacity: 0.6
    }};

    // Style for pending hover state
    const pendingHoverStyle = {{
      fillColor: '#a855f7',
      fillOpacity: 0.5,
      color: '#fff',
      weight: 2,
      opacity: 1
    }};

    // Helper to get style based on water_status
    function getStyle(waterStatus) {{
      if (waterStatus === 1) return waterStyle;
      if (waterStatus === -1) return protectedStyle;
      return normalStyle;
    }}

    function getHoverStyle(waterStatus) {{
      if (waterStatus === 1) return waterHoverStyle;
      if (waterStatus === -1) return protectedHoverStyle;
      return hoverStyle;
    }}

    // Add quadrant polygons
    quadrants.forEach(q => {{
      const style = getStyle(q.water_status);
      const hStyle = getHoverStyle(q.water_status);
      const polygon = L.polygon(q.corners, style).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(hStyle);
        let statusLabel = '';
        if (q.water_status === 1) {{
          statusLabel = ' <span style="color: #3b82f6;">üíß</span>';
        }} else if (q.water_status === -1) {{
          statusLabel = ' <span style="color: #dc2626;">üõ°Ô∏è</span>';
        }}
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
            ${{statusLabel}}
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(style);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add pending quadrant polygons (purple)
    pendingQuadrants.forEach(q => {{
      const polygon = L.polygon(q.corners, pendingStyle).addTo(map);

      polygon.on('mouseover', function(e) {{
        this.setStyle(pendingHoverStyle);
        coordsDisplay.innerHTML = `
          <div class="coords">
            <span class="label">x:</span><span class="x">${{q.x}}</span>
            <span class="separator">,</span>
            <span class="label">y:</span><span class="y">${{q.y}}</span>
            <span style="color: #a855f7;">‚è≥</span>
          </div>
        `;
      }});

      polygon.on('mouseout', function(e) {{
        this.setStyle(pendingStyle);
        coordsDisplay.innerHTML = '<span class="no-hover">Hover over a tile</span>';
      }});
    }});

    // Add seed point marker
    const seedIcon = L.divIcon({{
      className: 'seed-marker',
      html: `<div style="
        width: 14px;
        height: 14px;
        background: #10b981;
        border: 3px solid #fff;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      "></div>`,
      iconSize: [14, 14],
      iconAnchor: [7, 7]
    }});

    L.marker([seedLat, seedLng], {{ icon: seedIcon }})
      .addTo(map)
      .bindPopup('Seed Point');

    // Fit map to quadrant bounds if we have quadrants
    const allQuadrantCorners = [...quadrants, ...pendingQuadrants];
    if (allQuadrantCorners.length > 0) {{
      const allLatLngs = allQuadrantCorners.flatMap(q => q.corners);
      const bounds = L.latLngBounds(allLatLngs);
      map.fitBounds(bounds.pad(0.1));
    }}
  </script>
</body>
</html>
"""
  return html


def create_debug_map(
  generation_dir: Path,
  output_path: Path | None = None,
  bounds_path: Path | None = None,
) -> Path:
  """
  Create an interactive debug map showing generated quadrants overlaid on NYC.

  Args:
    generation_dir: Path to the generation directory
    output_path: Optional output path (default: generation_dir/debug_map.html)
    bounds_path: Optional path to custom bounds GeoJSON file (default: NYC)

  Returns:
    Path to the generated HTML file
  """
  db_path = generation_dir / "quadrants.db"
  if not db_path.exists():
    raise FileNotFoundError(f"Database not found: {db_path}")

  # Load boundary GeoJSON
  boundary_geojson = load_bounds(bounds_path)
  bounds_name = bounds_path.name if bounds_path else "NYC (default)"
  print(f"üìç Using boundary: {bounds_name}")

  # Connect to database
  conn = sqlite3.connect(db_path)

  try:
    # Load config
    config = get_generation_config(conn)
    print(f"üìÇ Loaded generation config: {config.get('name', 'unnamed')}")
    print(f"   Seed: {config['seed']['lat']:.6f}, {config['seed']['lng']:.6f}")
    print(
      f"   Camera: azimuth={config['camera_azimuth_degrees']}¬∞, "
      f"elevation={config['camera_elevation_degrees']}¬∞"
    )

    # Get generated quadrants
    generated = get_generated_quadrants(conn)
    print(f"\nüìä Found {len(generated)} generated quadrants")

    if not generated:
      print("‚ö†Ô∏è  No generated quadrants found. Creating empty map.")

    # Get pending quadrants from the generation queue
    pending = get_pending_quadrants(conn)
    # Filter out any pending quadrants that are already generated
    generated_set = {(qx, qy) for qx, qy, _ in generated}
    pending = [(qx, qy) for qx, qy in pending if (qx, qy) not in generated_set]
    if pending:
      print(f"   ‚è≥ {len(pending)} pending quadrants in queue")

    # Calculate corners for all generated quadrants
    print("\nüî≤ Calculating quadrant geographic footprints...")
    quadrant_polygons = []
    all_lats = []
    all_lngs = []
    water_count = 0
    protected_count = 0

    for qx, qy, water_status in generated:
      corners = calculate_quadrant_corners(config, qx, qy)
      quadrant_polygons.append((qx, qy, corners, water_status))

      if water_status == 1:
        water_count += 1
      elif water_status == -1:
        protected_count += 1

      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    # Calculate corners for pending quadrants
    pending_polygons = []
    for qx, qy in pending:
      corners = calculate_quadrant_corners(config, qx, qy)
      pending_polygons.append((qx, qy, corners))
      for lat, lng in corners:
        all_lats.append(lat)
        all_lngs.append(lng)

    if water_count > 0:
      print(f"   üíß {water_count} water tiles")
    if protected_count > 0:
      print(f"   üõ°Ô∏è  {protected_count} protected tiles")

    # Calculate center for map
    seed_lat = config["seed"]["lat"]
    seed_lng = config["seed"]["lng"]

    if all_lats and all_lngs:
      center_lat = (min(all_lats) + max(all_lats)) / 2
      center_lng = (min(all_lngs) + max(all_lngs)) / 2
    else:
      center_lat = seed_lat
      center_lng = seed_lng

    print("\nüó∫Ô∏è  Map center:")
    print(f"   Lat: {center_lat:.6f}")
    print(f"   Lng: {center_lng:.6f}")

    # Generate HTML
    print("\nüé® Generating interactive map...")
    html_content = generate_html(
      config=config,
      quadrant_polygons=quadrant_polygons,
      pending_polygons=pending_polygons,
      seed_lat=seed_lat,
      seed_lng=seed_lng,
      center_lat=center_lat,
      center_lng=center_lng,
      boundary_geojson=boundary_geojson,
    )

    # Set output path
    if output_path is None:
      output_path = generation_dir / "debug_map.html"

    # Save HTML file
    print(f"\nüíæ Saving to {output_path}")
    output_path.write_text(html_content)

    print(f"\n‚úÖ Debug map created: {output_path}")
    print(f"   Open in browser: file://{output_path.resolve()}")
    return output_path

  finally:
    conn.close()


def main():
  parser = argparse.ArgumentParser(
    description="Create an interactive debug map showing generated quadrants."
  )
  parser.add_argument(
    "generation_dir",
    type=Path,
    nargs="?",
    default=Path("generations/nyc"),
    help="Path to the generation directory (default: generations/nyc)",
  )
  parser.add_argument(
    "--output",
    "-o",
    type=Path,
    help="Output path for the debug map (default: generation_dir/debug_map.html)",
  )
  parser.add_argument(
    "--bounds",
    "-b",
    type=Path,
    help="Path to custom bounds GeoJSON file (default: NYC boundary)",
  )

  args = parser.parse_args()

  # Resolve paths
  generation_dir = args.generation_dir.resolve()

  if not generation_dir.exists():
    print(f"‚ùå Error: Directory not found: {generation_dir}")
    return 1

  output_path = args.output.resolve() if args.output else None
  bounds_path = args.bounds.resolve() if args.bounds else None

  print(f"\n{'=' * 60}")
  print("üó∫Ô∏è  Debug Map Generator (Interactive)")
  print(f"{'=' * 60}")
  print(f"   Generation dir: {generation_dir}")
  if bounds_path:
    print(f"   Bounds file: {bounds_path}")

  try:
    create_debug_map(generation_dir, output_path, bounds_path)
    return 0
  except FileNotFoundError as e:
    print(f"‚ùå Error: {e}")
    return 1
  except ValueError as e:
    print(f"‚ùå Validation error: {e}")
    return 1
  except Exception as e:
    print(f"‚ùå Unexpected error: {e}")
    raise


if __name__ == "__main__":
  exit(main())
